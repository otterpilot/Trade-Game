<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bavarian Trader - Final Syntax Fix</title>
    <style>
        /* --- CSS (Same) --- */
        :root{--bavarian-blue:#0066b2;--bavarian-white:#fff;--accent-green:#4CAF50;--accent-green-light:#81C784;--dark-bg:#22262e;--medium-bg:#2c313a;--light-bg:#3a3f4b;--text-color:#e8e8e8;--text-muted:#aaa;--border-color:#555;--event-bad:#d32f2f;--event-good:#4CAF50;--event-neutral:#FFC107; --spoilage-warning:#FFEB3B; --spoilage-spoiled:#F44336; --contract-color: #FF9800; }
        body{margin:0;overflow:hidden;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background-color:var(--dark-bg);color:var(--text-color);display:flex;flex-direction:column;height:100vh}
        #game-container{flex-grow:1;position:relative;min-height:350px}
        canvas{display:block;position:absolute;top:0;left:0;width:100%;height:100%;z-index:1}
        #css-label-container{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;overflow:hidden}
        .town-label{background-color:rgba(0,0,0,0.7);color:var(--bavarian-white);padding:4px 8px;border-radius:5px;font-size:12px;font-weight:bold;white-space:nowrap;user-select:none;border:1px solid var(--bavarian-blue);text-shadow:1px 1px 3px black;transition: background-color .3s, color .3s, border-color .3s, transform .2s, padding .2s; max-width: 200px; overflow: hidden; text-overflow: ellipsis;}
        .town-label .travel-time { font-size: 0.9em; font-style: italic; color: var(--text-muted); margin-left: 5px; }
        #ui-panel{background-color:rgba(34,38,46,0.97);padding:15px 20px;border-top:4px solid var(--bavarian-blue);max-height:48vh;overflow-y:auto;display:flex;gap:15px; flex-wrap:wrap;box-shadow:0 -3px 15px rgba(0,0,0,0.6);z-index:10}
        .ui-section{background-color:var(--medium-bg);padding:12px 15px;border-radius:6px;min-width:200px; flex:1;box-shadow:inset 0 0 8px rgba(0,0,0,0.4)}
        .ui-section h3{margin-top:0;margin-bottom:12px;color:var(--bavarian-blue);border-bottom:1px solid var(--border-color);padding-bottom:6px;font-size:1.1em}
        .ui-section p,.ui-section li{font-size:.85em;margin-bottom:5px;line-height:1.35}
        .ui-section ul{list-style:none;padding:0;max-height:130px; overflow-y:auto;margin:0}
        #player-inventory li{background-color:var(--light-bg);padding:4px 7px;margin-bottom:4px;border-radius:4px;font-size:.8em;border-left:3px solid var(--accent-green); position: relative;}
        #player-inventory li.spoilage-warning { border-left-color: var(--spoilage-warning); background-color: #4a4a33; }
        #player-inventory li.spoilage-spoiled { border-left-color: var(--spoilage-spoiled); background-color: #4a3333; text-decoration: line-through; color: var(--text-muted)}
        .spoilage-indicator { font-size: 0.8em; color: var(--spoilage-warning); margin-left: 10px; font-style: italic; }
        .spoilage-spoiled-text { font-size: 0.8em; color: var(--spoilage-spoiled); margin-left: 10px; font-weight: bold; }
        #player-inventory .inv-details{font-size:.85em;color:var(--text-muted);margin-left:10px;display:block}
        #player-inventory .inv-count{font-weight:bold;min-width:12px;display:inline-block}
        #contracts-list li { background-color: var(--light-bg); padding: 4px 7px; margin-bottom: 4px; border-radius: 4px; font-size: .8em; border-left: 3px solid var(--contract-color); }
        .contract-details { font-size: 0.9em; color: var(--text-muted); display: block; margin-top: 2px;}
        .contract-destination { font-weight: bold; color: var(--bavarian-blue); }
        .contract-reward { color: var(--accent-green); font-weight: bold; }
        .contract-deadline { color: var(--spoilage-warning); }
        #market-table{width:100%;border-collapse:collapse;font-size:.8em}
        #market-table th,#market-table td{border:1px solid var(--border-color);padding:5px 8px;text-align:left}
        #market-table th{background-color:var(--light-bg);color:var(--bavarian-blue)}
        #market-table tr:nth-child(even){background-color:var(--medium-bg)}
        #market-table tr:hover{background-color:#4e5563}
        button{background-color:var(--bavarian-blue);color:var(--bavarian-white);border:none;padding:5px 10px;border-radius:4px;cursor:pointer;font-size:.85em;transition:background-color .2s ease,transform .1s ease;margin:2px;font-weight:500}
        button:hover{background-color:#007cce;transform:translateY(-1px)}button:active{transform:translateY(0)}button:disabled{background-color:#555;color:#aaa;cursor:not-allowed;transform:none}
        .upgrade-button{background-color:var(--accent-green);margin-top:8px}.upgrade-button:hover{background-color:var(--accent-green-light)}
        #instructions{position:absolute;top:10px;left:10px;background-color:rgba(40,44,52,0.85);padding:10px 15px;border-radius:5px;font-size:.8em;z-index:50;max-width:280px;color:#eee;border:1px solid var(--bavarian-blue);box-shadow:2px 2px 5px rgba(0,0,0,0.3)}
        #instructions p{margin:3px 0}#instructions strong{color:var(--bavarian-blue)}
        #game-info-bar { position:absolute; top:10px; right:10px; display:flex; gap: 10px; z-index:50;}
        #time-display{background-color:rgba(40,44,52,0.85);padding:6px 12px;border-radius:4px;font-size:.9em;border:1px solid #777;box-shadow:-2px 2px 5px rgba(0,0,0,0.3)}
        #reset-btn { background-color: var(--event-bad); padding: 6px 10px; font-size: .85em; }
        #reset-btn:hover { background-color: #e57373; }
        #event-notification{ position:absolute;bottom:calc(48vh + 20px);left:50%;transform:translateX(-50%);color:#fff;padding:10px 20px;border-radius:6px;font-size:.9em;z-index:150;box-shadow:0 0 15px rgba(0,0,0,0.5);opacity:0;transition:opacity .5s ease-in-out,background-color .3s ease;pointer-events:none;text-align:center;background-color:var(--event-neutral)}
        #event-notification.bad-event{background-color:var(--event-bad)}#event-notification.good-event{background-color:var(--event-good)}#event-notification.show{opacity:1}
        .overlay-prompt { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 190; justify-content: center; align-items: center; }
        .overlay-prompt.show { display: flex; }
        .prompt-box { background-color: var(--medium-bg); padding: 30px 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.5); border: 2px solid var(--bavarian-blue); }
        .prompt-box h2 { margin-top: 0; color: var(--bavarian-blue); }
        .prompt-box p { margin-bottom: 20px; font-size: 1.1em; }
        .prompt-box button { font-size: 1em; padding: 10px 20px; margin: 0 10px; }
        #win-message { transform: translate(-50%,-50%); background-color:#FFC107; color:#333; font-size:1.8em; font-weight:bold; border-color: #FFA000; }
        #win-message small { font-size: 0.6em; display: block; margin-top: 10px; }
        #region-complete-prompt h2 { color: var(--accent-green); }
        .good-color-swatch{display:inline-block;width:10px;height:10px;margin-right:5px;border:1px solid #ccc;vertical-align:middle;border-radius:2px}
        .town-origin{font-style:italic;color:var(--text-muted)}
    </style>
</head>
<body>
    <!-- HTML Structure remains the same -->
    <div id="instructions">
        <p><strong id="game-title">Bavarian Trader</strong></p>
        <p>Goal: Reach <span id="win-goal-display">1500</span> Gold!</p>
        <p>Buy/Sell goods. Prices dynamic. Events & market shifts!</p>
        <p>Travel costs time & money. Goods spoil!</p>
        <p>Fulfill contracts. Upgrade cargo!</p>
        <p>Rotate: Left Drag, Zoom: Scroll</p>
        <p>Hover over town for travel time.</p>
        <p style="color: var(--text-muted);">Debug: Press Shift+D to add Gold.</p>
    </div>
    <div id="game-info-bar">
        <div id="time-display">Day: <span id="game-day">0</span></div>
        <button id="reset-btn">Reset Game</button>
    </div>
    <div id="event-notification">Event Text</div>
    <div id="game-container"></div>
    <div id="ui-panel">
         <div class="ui-section" id="player-status">
             <h3>Your Status</h3>
             <p>Gold: <span id="player-gold">100</span> G</p>
             <p>Cargo: <span id="player-cargo-current">0</span> / <span id="player-cargo-capacity">15</span></p>
             <button id="upgrade-cargo-btn" class="upgrade-button">Upgrade Cargo (Cost: <span id="upgrade-cost">0</span> G)</button>
             <p style="margin-top:10px;">Inventory:</p>
             <ul id="player-inventory"></ul>
         </div>
         <div class="ui-section" id="contracts-section">
             <h3>Active Contracts</h3>
             <ul id="contracts-list"><li>(None)</li></ul>
         </div>
         <div class="ui-section" id="town-info">
             <h3>Current Town: <span id="current-town-name">None</span></h3>
             <p>Specialty: <span id="town-produces">N/A</span></p>
             <p>Demand: <span id="town-demands">N/A</span></p>
             <div id="market-controls">
                 <h3 style="margin-top:10px;">Marketplace</h3>
                 <table id="market-table">
                     <thead><tr><th>Good</th><th>Stock</th><th>You Have</th><th>Buy Price</th><th>Sell Price</th><th>Actions</th></tr></thead>
                     <tbody id="market-body"></tbody>
                 </table>
            </div>
        </div>
    </div>
    <div id="region-complete-prompt" class="overlay-prompt">
        <div class="prompt-box">
            <h2 id="region-complete-title">Region Complete!</h2>
            <p id="region-complete-text">...</p>
            <button id="continue-btn">Continue to Next Region</button>
            <button id="stop-btn">Stop Here</button>
        </div>
    </div>
    <div id="win-message" class="overlay-prompt">
         <div class="prompt-box">
             <h2>ðŸŽ‰ GRAND TRADER! ðŸŽ‰</h2>
             <small id="win-message-text">...</small>
         </div>
    </div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        console.log("--- Trader Game Script Starting (Final Syntax Fix) ---");

        // --- Configuration & Data ---
        const TOWN_COUNT = 8;
        const MAP_SIZE = 80;
        const TOWN_RADIUS_BASE = 1.8;
        const PLAYER_START_GOLD = 100;
        const PLAYER_START_CAPACITY = 15;
        const PLAYER_MAX_CAPACITY = 50;
        const CARGO_UPGRADE_BASE_COST = 150;
        const CARGO_UPGRADE_INCREMENT = 5;
        const MARKET_SHIFT_INTERVAL = 10;
        const EVENT_PROBABILITY = 0.15;
        const PRICE_ADJUST_BUY_FACTOR = 1.03;
        const PRICE_ADJUST_SELL_FACTOR = 0.97;
        const SHOW_TRADE_PARTICLES = true;
        const SPOILAGE_DAYS = 8;
        const SPOILAGE_WARNING_DAYS = 2;
        const BASE_TRAVEL_COST = 3;
        const COST_PER_DISTANCE_UNIT = 0.15;
        const BASE_TRAVEL_DAYS = 1;
        const DAYS_PER_DISTANCE_UNIT = 0.08;
        const MAX_TRAVEL_DAYS = 5;
        const CONTRACT_OFFER_CHANCE = 0.35;
        const MAX_ACTIVE_CONTRACTS = 3;
        const CONTRACT_DEADLINE_MIN_DAYS = 8;
        const CONTRACT_DEADLINE_MAX_DAYS = 20;
        const CONTRACT_REWARD_FACTOR = 1.8;
        const regionThemes = [
            { name: "Bavaria", townNames: ["MÃ¼nchen", "NÃ¼rnberg", "Augsburg", "Regensburg", "WÃ¼rzburg", "Ingolstadt", "Passau", "Bamberg"], goods: [ {id:'bier', name:'Beer', basePrice:12, color:'#DAA520', perishable: true}, {id:'brezen', name:'Pretzels', basePrice:8, color:'#CD853F', perishable: true}, {id:'lederhosen', name:'Lederhosen', basePrice:50, color:'#8B4513', perishable: false}, {id:'weisswurst', name:'Sausages', basePrice:18, color:'#F5F5DC', perishable: true}, {id:'holz', name:'Timber', basePrice:15, color:'#A0522D', perishable: false}, {id:'salz', name:'Salt', basePrice:22, color:'#FFFAFA', perishable: false}, {id:'glas', name:'Glassware', basePrice:35, color:'#AFEEEE', perishable: false} ], winTarget: 1500 },
            { name: "Swabia", townNames: ["Stuttgart", "Ulm", "Heilbronn", "Reutlingen", "TÃ¼bingen", "Konstanz", "Friedrichshafen", "Aalen"], goods: [ {id: 'spaetzle', name: 'SpÃ¤tzle', basePrice: 10, color: '#F0E68C', perishable: true}, {id: 'maultaschen', name: 'Maultaschen', basePrice: 16, color: '#D2B48C', perishable: true}, {id: 'clocks', name: 'Cuckoo Clocks', basePrice: 60, color: '#8B4513', perishable: false}, {id: 'tools', name: 'Precision Tools', basePrice: 75, color: '#C0C0C0', perishable: false}, {id: 'wine_sw', name: 'Swabian Wine', basePrice: 20, color: '#B22222', perishable: false}, {id: 'textiles', name: 'Fine Textiles', basePrice: 40, color: '#4682B4', perishable: false}, {id: 'kirsch', name: 'Kirschwasser', basePrice: 30, color: '#DC143C', perishable: false} ], winTarget: 4000 },
            { name: "Franconia", townNames: ["NÃ¼rnberg-F", "WÃ¼rzburg-F", "Bamberg-F", "Bayreuth", "Coburg", "Ansbach", "FÃ¼rth", "Erlangen"], goods: [ {id: 'wine_fr', name: 'Franconian Wine', basePrice: 25, color: '#800020', perishable: false}, {id: 'toys', name: 'Wooden Toys', basePrice: 18, color: '#DEB887', perishable: false}, {id: 'lebkuchen', name: 'Gingerbread', basePrice: 14, color: '#A0522D', perishable: false}, {id: 'bratwurst_fr', name: 'NÃ¼rnberger Bratwurst', basePrice: 20, color: '#F5F5DC', perishable: true}, {id: 'ceramics_fr', name: 'Ceramics', basePrice: 32, color: '#BDB76B', perishable: false}, {id: 'hops', name: 'Hops', basePrice: 11, color: '#90EE90', perishable: true}, {id: 'metalwork', name: 'Metalwork', basePrice: 45, color: '#778899', perishable: false} ], winTarget: 8000 },
            { name: "Iberia", townNames: ["Madrid", "Lisbon", "Seville", "Barcelona", "Valencia", "Porto", "Bilbao", "Zaragoza"], goods: [ {id: 'olive_oil', name: 'Olive Oil', basePrice: 18, color: '#808000', perishable: false}, {id: 'wine_ib', name: 'Iberian Wine', basePrice: 22, color: '#8B0000', perishable: false}, {id: 'oranges', name: 'Oranges', basePrice: 9, color: '#FFA500', perishable: true}, {id: 'fish', name: 'Salted Fish', basePrice: 15, color: '#ADD8E6', perishable: true}, {id: 'cork', name: 'Cork', basePrice: 12, color: '#D2B48C', perishable: false}, {id: 'ceramics_ib', name: 'Painted Tiles', basePrice: 38, color: '#4682B4', perishable: false}, {id: 'wool', name: 'Merino Wool', basePrice: 42, color: '#FFF8DC', perishable: false}, {id: 'steel', name: 'Toledo Steel', basePrice: 65, color: '#808080', perishable: false} ], winTarget: 15000 }
        ];
        let currentRegionIndex = 0;

        // --- Game State / Three.js Variables / DOM Elements (Remain the same structure) ---
        let currentGoods = []; let goodMap = new Map(); let PERISHABLE_GOODS = new Set(); let currentWinTarget = 0;
        let towns = []; let townNameMap = new Map(); let inventoryItemCounter = 0; let contractIdCounter = 0; let travelCount = 0;
        let player = { gold: PLAYER_START_GOLD, inventory: [], capacity: PLAYER_START_CAPACITY, currentTownId: null, contracts: [] };
        let gameWon = false; let regionComplete = false; let eventTimeoutId = null; let lastMarketShiftDay = 0;
        let currentlyHoveredTownId = null; let originalLabelContent = null;
        let scene, camera, renderer, css2dRenderer, controls;
        let raycaster, mouse;
        let townObjects = []; let townLabels = []; let routeLines = null;
        let arrivalParticleSystem, tradeParticleSystem;
        const clock = new THREE.Clock(true);
        const container = document.getElementById('game-container');
        const playerGoldEl = document.getElementById('player-gold');
        const playerCargoCurrentEl = document.getElementById('player-cargo-current');
        const playerCargoCapacityEl = document.getElementById('player-cargo-capacity');
        const playerInventoryEl = document.getElementById('player-inventory');
        const contractsListEl = document.getElementById('contracts-list');
        const currentTownNameEl = document.getElementById('current-town-name');
        const townProducesEl = document.getElementById('town-produces');
        const townDemandsEl = document.getElementById('town-demands');
        const marketBodyEl = document.getElementById('market-body');
        const gameDayEl = document.getElementById('game-day');
        const upgradeCargoBtn = document.getElementById('upgrade-cargo-btn');
        const upgradeCostEl = document.getElementById('upgrade-cost');
        const eventNotificationEl = document.getElementById('event-notification');
        const gameTitleEl = document.getElementById('game-title');
        const winGoalDisplayEl = document.getElementById('win-goal-display');
        const resetBtn = document.getElementById('reset-btn');
        const regionCompletePrompt = document.getElementById('region-complete-prompt');
        const regionCompleteTitle = document.getElementById('region-complete-title');
        const regionCompleteText = document.getElementById('region-complete-text');
        const continueBtn = document.getElementById('continue-btn');
        const stopBtn = document.getElementById('stop-btn');
        const winMessage = document.getElementById('win-message');
        const winMessageText = document.getElementById('win-message-text');

        // --- Initialization ---
        function init() { console.log("init() called"); try { initThreeJSCore(); setupEventListeners(); startGameRegion(0); console.log("Init complete. Starting loop..."); requestAnimationFrame(animate); } catch (error) { console.error("Init failed:", error); container.innerHTML = `<p style='color:red; padding:20px;'>Initialization Error: ${error.message}. Check console (F12) for details.</p>`; } }

        // --- Start or Transition Region ---
        function startGameRegion(regionIndex, keepPlayerStats = false) { console.log(`--- Starting Region ${regionIndex}: ${regionThemes[regionIndex]?.name || 'Unknown'} ---`); currentRegionIndex = regionIndex; gameWon = false; regionComplete = false; currentlyHoveredTownId = null; originalLabelContent = null; let savedGold = player.gold; let savedCapacity = player.capacity; const theme = regionThemes[currentRegionIndex]; currentGoods = theme.goods; currentWinTarget = theme.winTarget; goodMap = new Map(currentGoods.map(g => [g.id, g])); PERISHABLE_GOODS = new Set(currentGoods.filter(g => g.perishable).map(g => g.id)); initGameData(keepPlayerStats ? { gold: savedGold, capacity: savedCapacity } : null); if (towns.length > 0) { player.currentTownId = towns[0].id; console.log(`Player starting at: ${towns[0].name}`); } else { console.error("No towns generated!"); return; } clearMapObjects(); buildMapObjects(); updateUI(); hidePrompts(); disableInteractionButtons(false); console.log(`Region ${regionIndex} setup complete.`); }

        // --- Game Data Setup ---
        function initGameData(restoreStats = null) { console.log("initGameData() started"); const theme = regionThemes[currentRegionIndex]; player.gold = restoreStats ? restoreStats.gold : PLAYER_START_GOLD; player.capacity = restoreStats ? restoreStats.capacity : PLAYER_START_CAPACITY; player.inventory = []; player.contracts = []; player.currentTownId = null; inventoryItemCounter = 0; contractIdCounter = 0; travelCount = 0; lastMarketShiftDay = 0; towns = []; townNameMap.clear(); const townNames = shuffleArray([...theme.townNames]); const colors = shuffleArray([0x0066b2,0xff6347,0x32cd32,0xffd700,0x6a5acd,0xdb7093,0x20b2aa,0xffa500, 0xFFA500, 0x00CED1]); for(let i=0; i < Math.min(TOWN_COUNT, townNames.length); i++) { const a=(i/Math.min(TOWN_COUNT,townNames.length))*Math.PI*2; const r=MAP_SIZE*0.35; const x=Math.cos(a)*r+(Math.random()-0.5)*(MAP_SIZE*0.1); const z=Math.sin(a)*r+(Math.random()-0.5)*(MAP_SIZE*0.1); const id=`town_${i}`; const name=townNames[i]; const town={id:id,name:name,x:x,z:z,color:colors[i%colors.length],produces:'',demands:'',market:{}}; townNameMap.set(id,name); towns.push(town); } assignSpecialtiesAndDemands(true); console.log("initGameData() finished"); }
        function assignSpecialtiesAndDemands(isInitialSetup = false) { console.log(`--- ${isInitialSetup?'Init Market':'Market Shift'} Day ${travelCount} ---`); const currentGoodIds=currentGoods.map(g=>g.id); if(currentGoodIds.length<2){console.error("Not enough goods!");return;} let producerIds=shuffleArray([...currentGoodIds]); let demanderIds=shuffleArray([...currentGoodIds]); for(let i=0;i<towns.length;i++){const pIndex=i%producerIds.length; let dIndex=i%demanderIds.length; if(producerIds[pIndex]===demanderIds[dIndex]){const nextDIndex=(i+1)%towns.length%demanderIds.length; [demanderIds[dIndex],demanderIds[nextDIndex]]=[demanderIds[nextDIndex],demanderIds[dIndex]]; dIndex=i%demanderIds.length; if(producerIds[pIndex]===demanderIds[dIndex]){console.warn(`Conflict ${towns[i].name}`); let fallbackDemand=demanderIds.find(id=>id!==producerIds[pIndex]); if(fallbackDemand)demanderIds[dIndex]=fallbackDemand;}} towns[i].produces=producerIds[pIndex]; towns[i].demands=demanderIds[dIndex]; updateTownMarketPrices(towns[i]);} }
        function updateTownMarketPrices(town) { currentGoods.forEach(good=>{ let buy=good.basePrice;let sell=Math.round(buy*0.8);let stock=15; if(good.id===town.produces){buy=Math.round(buy*0.6);sell=Math.round(buy*0.8);stock+=20;}else if(good.id===town.demands){buy=Math.round(buy*1.7);sell=Math.round(buy*0.9);stock=5;} if(sell>=buy){sell=Math.max(1,buy-1);} buy=Math.max(1,buy); sell=Math.max(1,sell); stock=Math.max(0,stock); town.market[good.id]={stock:stock,buyPrice:buy,sellPrice:sell}; });}
        function shuffleArray(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]]}return array;}

        // --- 3D Setup ---
        function initThreeJSCore() { console.log("initThreeJSCore() started"); scene=new THREE.Scene(); scene.background=new THREE.Color(0x22262e); scene.fog=new THREE.Fog(0x22262e,MAP_SIZE*0.7,MAP_SIZE*2.0); const aspect=container.clientWidth/container.clientHeight; camera=new THREE.PerspectiveCamera(60,aspect,0.1,1000); camera.position.set(0,MAP_SIZE*1.1,MAP_SIZE*0.9); camera.lookAt(0,0,0); scene.add(camera); renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(container.clientWidth,container.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); container.appendChild(renderer.domElement); css2dRenderer=new CSS2DRenderer(); css2dRenderer.setSize(container.clientWidth,container.clientHeight); css2dRenderer.domElement.style.position='absolute'; css2dRenderer.domElement.style.top='0px'; css2dRenderer.domElement.id='css-label-container'; container.appendChild(css2dRenderer.domElement); const ambientLight=new THREE.AmbientLight(0xffffff,0.65); scene.add(ambientLight); const directionalLight=new THREE.DirectionalLight(0xffeedd,1.0); directionalLight.position.set(MAP_SIZE*0.6,MAP_SIZE*1.1,MAP_SIZE*0.8); scene.add(directionalLight); const planeGeometry=new THREE.PlaneGeometry(MAP_SIZE*1.5,MAP_SIZE*1.5); const planeMaterial=new THREE.MeshStandardMaterial({color:0x3a4150,roughness:0.9}); const groundPlane=new THREE.Mesh(planeGeometry,planeMaterial); groundPlane.rotation.x=-Math.PI/2; groundPlane.position.y=-0.1; scene.add(groundPlane); controls=new OrbitControls(camera,renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05; controls.target.set(0,0,0); controls.maxPolarAngle=Math.PI/2-0.01; controls.minDistance=5; controls.maxDistance=MAP_SIZE*2; raycaster=new THREE.Raycaster(); mouse=new THREE.Vector2(); initParticleSystems(); console.log("initThreeJSCore() finished."); }
        function clearMapObjects() { console.log(`Clearing map objects... Towns: ${townObjects.length}, Labels: ${townLabels.length}`); townObjects.forEach(obj => { if(obj) scene.remove(obj); }); townLabels.forEach(label => { if(label) scene.remove(label); }); if(routeLines) { scene.remove(routeLines); routeLines.geometry.dispose(); routeLines.material.dispose(); } townObjects = []; townLabels = []; routeLines = null; console.log("Map objects cleared."); }
        function buildMapObjects() { console.log(`Building map objects for ${towns.length} towns...`); const townGeometry=new THREE.SphereGeometry(1,16,12); towns.forEach((townData,i)=>{try{ const material=new THREE.MeshStandardMaterial({color:townData.color,metalness:0.2,roughness:0.6}); const mesh=new THREE.Mesh(townGeometry,material); const scale=TOWN_RADIUS_BASE*(0.9+Math.random()*0.2); mesh.scale.set(scale,scale,scale); mesh.position.set(townData.x,scale/2,townData.z); mesh.userData={townId:townData.id,type:'town',radius:scale}; scene.add(mesh); townObjects.push(mesh); const div=document.createElement('div'); div.className='town-label'; div.textContent=townData.name; div.style.color=`#${new THREE.Color(townData.color).getHexString()}`; div.style.borderColor=`#${new THREE.Color(townData.color).getHexString()}`; const label=new CSS2DObject(div); label.position.set(townData.x,scale*1.5+0.5,townData.z); label.userData={townId:townData.id}; scene.add(label); townLabels.push(label);}catch(e){console.error(`Error creating town ${i} (${townData.name}):`,e);}}); townGeometry.dispose(); console.log(`${townObjects.length} towns & ${townLabels.length} labels added to scene.`); createRouteLines(); }
        function createRouteLines() { console.log("createRouteLines() called"); if(routeLines) scene.remove(routeLines); const points=[]; for(let i=0;i<towns.length;++i){ for(let j=i+1;j<towns.length;++j){ const dx=towns[i].x-towns[j].x; const dz=towns[i].z-towns[j].z; const dist=Math.sqrt(dx*dx+dz*dz); if(dist<MAP_SIZE*0.55){ points.push(new THREE.Vector3(towns[i].x,0.1,towns[i].z)); points.push(new THREE.Vector3(towns[j].x,0.1,towns[j].z));}}} if(points.length>0){ const geometry=new THREE.BufferGeometry().setFromPoints(points); const material=new THREE.LineBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.4}); routeLines=new THREE.LineSegments(geometry,material); scene.add(routeLines); console.log(`Route lines added.`); } else { console.log("No route lines generated."); routeLines=null; } }

        // --- Particle Systems ---
        function initParticleSystems() { console.log("initParticleSystems() started"); try { const pc=100;const p=new Float32Array(pc*3);const c=new Float32Array(pc*3);const a=new Float32Array(pc);const s=new Float32Array(pc);const g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.BufferAttribute(p,3));g.setAttribute('color',new THREE.BufferAttribute(c,3));g.setAttribute('alpha',new THREE.BufferAttribute(a,1));g.setAttribute('size',new THREE.BufferAttribute(s,1));const m=new THREE.PointsMaterial({vertexColors:true,size:0.8,sizeAttenuation:true,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending});arrivalParticleSystem=new THREE.Points(g.clone(),m.clone());arrivalParticleSystem.userData={particles:[],active:false,lifetime:1.5,time:0};scene.add(arrivalParticleSystem);if(SHOW_TRADE_PARTICLES){tradeParticleSystem=new THREE.Points(g.clone(),m.clone());tradeParticleSystem.userData={particles:[],active:false,lifetime:0.8,time:0};scene.add(tradeParticleSystem);}g.dispose(); m.dispose(); console.log("Particle systems initialized.");}catch(e){console.error("!!! Error init particles:",e);arrivalParticleSystem=null;tradeParticleSystem=null;} }
        function triggerArrivalParticles(position, baseColor) { if (!arrivalParticleSystem){return;} try { const s=arrivalParticleSystem; const ud=s.userData; const pts=ud.particles=[]; const pos=s.geometry.attributes.position.array; const cls=s.geometry.attributes.color.array; const als=s.geometry.attributes.alpha.array; const szs=s.geometry.attributes.size.array; const clr=new THREE.Color(baseColor); for (let i = 0; i < pos.length / 3; i++) { const i3 = i * 3; const townMesh = townObjects.find(to => to.userData.townId === player.currentTownId); const radius = townMesh ? townMesh.userData.radius : TOWN_RADIUS_BASE; pos[i3 + 0] = position.x; pos[i3 + 1] = position.y + radius * 0.5; pos[i3 + 2] = position.z; const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const sp=5+Math.random()*10; const v={x:Math.sin(ph)*Math.cos(th)*sp,y:Math.cos(ph)*sp+(2+Math.random()*3),z:Math.sin(ph)*Math.sin(th)*sp}; const c=clr.clone().offsetHSL(0,(Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2); cls[i3 + 0] = c.r; cls[i3 + 1] = c.g; cls[i3 + 2] = c.b; als[i] = 1.0; szs[i] = 0.8 + Math.random() * 0.5; pts.push({velocity:v, initialSize:szs[i]}); } s.geometry.attributes.position.needsUpdate=true; s.geometry.attributes.color.needsUpdate=true; s.geometry.attributes.alpha.needsUpdate=true; s.geometry.attributes.size.needsUpdate=true; ud.active=true; ud.time=0; } catch (e) { console.error("Err trigger arrival particles:", e); } }
        function triggerTradeParticles(position, goodColor = 0xFFD700) { if(!SHOW_TRADE_PARTICLES||!tradeParticleSystem){return;} try{const s=tradeParticleSystem;const ud=s.userData;const pts=ud.particles=[];const pos=s.geometry.attributes.position.array;const cls=s.geometry.attributes.color.array;const als=s.geometry.attributes.alpha.array;const szs=s.geometry.attributes.size.array;const cnt=30;const clr=new THREE.Color(goodColor);for(let i=0;i<cnt;i++){const i3=i*3; const townMesh = townObjects.find(to => to.userData.townId === player.currentTownId); const radius = townMesh ? townMesh.userData.radius : TOWN_RADIUS_BASE; pos[i3+0]=position.x; pos[i3+1]=position.y+radius*0.25; pos[i3+2]=position.z; const sp=3+Math.random()*5; const v={x:(Math.random()-0.5)*sp,y:(Math.random()*0.8+0.2)*sp,z:(Math.random()-0.5)*sp};cls[i3+0]=clr.r;cls[i3+1]=clr.g;cls[i3+2]=clr.b; als[i]=0.8; szs[i]=0.5+Math.random()*0.3; pts.push({velocity:v,initialSize:szs[i]});}for(let i=cnt;i<pos.length/3;i++){als[i]=0.0;} s.geometry.attributes.position.needsUpdate=true; s.geometry.attributes.color.needsUpdate=true; s.geometry.attributes.alpha.needsUpdate=true; s.geometry.attributes.size.needsUpdate=true; ud.active=true; ud.time=0;}catch(e){console.error("Err trigger trade particles:",e);} }
        function updateParticleSystems(deltaTime) { const dt = (deltaTime <= 1e-6 || isNaN(deltaTime)) ? (1 / 60) : deltaTime; [arrivalParticleSystem, tradeParticleSystem].forEach((system) => { if (!system || !system.userData || !system.userData.active) return; try { const userData = system.userData; userData.time += dt; const positions = system.geometry.attributes.position?.array; const alphas = system.geometry.attributes.alpha?.array; const sizes = system.geometry.attributes.size?.array; const particles = userData.particles; if (!positions || !alphas || !sizes || !particles || particles.length === 0) { userData.active = false; return; } let needsPosUpdate = false; let needsAlphaSizeUpdate = false; const timeRatio = Math.max(0, Math.min(1, userData.time / userData.lifetime)); for (let i = 0; i < particles.length; i++) { const i3 = i * 3; const pData = particles[i]; const dx = pData.velocity.x * dt; const dy = pData.velocity.y * dt; const dz = pData.velocity.z * dt; if (Math.abs(dx) > 1e-6 || Math.abs(dy) > 1e-6 || Math.abs(dz) > 1e-6) { positions[i3 + 0] += dx; positions[i3 + 1] += dy; positions[i3 + 2] += dz; needsPosUpdate = true; } pData.velocity.y -= 9.8 * dt; const currentAlpha = 1.0 - timeRatio * timeRatio; const currentSize = pData.initialSize * (1.0 - timeRatio); if (Math.abs(alphas[i] - currentAlpha) > 1e-3 || Math.abs(sizes[i] - currentSize) > 1e-3) { alphas[i] = Math.max(0, currentAlpha); sizes[i] = Math.max(0, currentSize); needsAlphaSizeUpdate = true; } } if (needsPosUpdate) system.geometry.attributes.position.needsUpdate = true; if (needsAlphaSizeUpdate) { system.geometry.attributes.alpha.needsUpdate = true; system.geometry.attributes.size.needsUpdate = true; } if (userData.time >= userData.lifetime) { userData.active = false; for (let i = 0; i < alphas.length; i++) { alphas[i] = 0; } system.geometry.attributes.alpha.needsUpdate = true; } } catch(e) { console.error("Error updating particle system:", e); if(system && system.userData) system.userData.active = false; } }); }

        // --- UI Update Logic ---
        function updateUI() {
             if (regionComplete || gameWon) {
                 gameDayEl.textContent = travelCount; playerGoldEl.textContent = player.gold;
                 const marketControls = document.getElementById('market-controls');
                 if (marketControls) marketControls.style.display = 'none';
                 return;
             }
             // --- Start Try Block ---
             try {
                 const theme = regionThemes[currentRegionIndex]; gameTitleEl.textContent=`${theme.name} Trader`; winGoalDisplayEl.textContent=currentWinTarget;
                 gameDayEl.textContent = travelCount; playerGoldEl.textContent = player.gold; const currentCargo=player.inventory.length; playerCargoCurrentEl.textContent=currentCargo; playerCargoCapacityEl.textContent=player.capacity;

                 // --- Inventory Display ---
                 playerInventoryEl.innerHTML = '';
                 if (currentCargo === 0) {
                     playerInventoryEl.innerHTML = '<li>(Empty)</li>';
                 } else { // Start inventory ELSE
                     const groupedInventory = {};
                     player.inventory.forEach(item => { if (!groupedInventory[item.goodId]) { groupedInventory[item.goodId] = []; } groupedInventory[item.goodId].push(item); });
                     for (const goodId in groupedInventory) { // Start FOR...IN inventory
                         const items = groupedInventory[goodId];
                         const good = goodMap.get(goodId);
                         if (!good) { console.warn(`Inv item ${goodId} not in goodMap!`); continue; }
                         const count = items.length;
                         const avgPurchasePrice = items.reduce((sum, item) => sum + item.purchasePrice, 0) / count;
                         const li = document.createElement('li');
                         const swatch = document.createElement('span'); swatch.className = 'good-color-swatch'; swatch.style.backgroundColor = good.color; li.appendChild(swatch);
                         const countSpan = document.createElement('span'); countSpan.className = 'inv-count'; countSpan.textContent = count; li.appendChild(countSpan);
                         li.appendChild(document.createTextNode(` x ${good.name}`));
                         if (PERISHABLE_GOODS.has(goodId)) { // Start IF perishable
                             const oldestItem = items.reduce((oldest, current) => (current.purchaseDay < oldest.purchaseDay ? current : oldest), items[0]);
                             const daysHeld = travelCount - oldestItem.purchaseDay;
                             const daysLeft = SPOILAGE_DAYS - daysHeld;
                             if (daysLeft <= 0) { li.classList.add('spoilage-spoiled'); const spoiledText = document.createElement('span'); spoiledText.className = 'spoilage-spoiled-text'; spoiledText.textContent = '(Spoiled)'; li.appendChild(spoiledText);
                             } else if (daysLeft <= SPOILAGE_WARNING_DAYS) { li.classList.add('spoilage-warning'); const warningText = document.createElement('span'); warningText.className = 'spoilage-indicator'; warningText.textContent = `(Spoils in ${daysLeft}d)`; li.appendChild(warningText);
                             } // End ELSE IF spoilage warning
                         } // End IF perishable
                         const detailsSpan = document.createElement('span'); detailsSpan.className = 'inv-details'; detailsSpan.innerHTML = `Avg. Buy: ${avgPurchasePrice.toFixed(1)} G`; li.appendChild(detailsSpan);
                         playerInventoryEl.appendChild(li);
                     } // End FOR...IN inventory
                 } // End inventory ELSE

                 // --- Contracts Display ---
                 contractsListEl.innerHTML = '';
                 if (player.contracts.length === 0) { contractsListEl.innerHTML = '<li>(None)</li>';
                 } else { // Start contracts ELSE
                     player.contracts.forEach(contract => { // Start contracts FOR EACH
                         const good = goodMap.get(contract.goodId); const destinationTown = townNameMap.get(contract.destinationTownId); if (!good || !destinationTown) return;
                         const li = document.createElement('li'); const swatch = document.createElement('span'); swatch.className = 'good-color-swatch'; swatch.style.backgroundColor = good.color; li.appendChild(swatch);
                         li.appendChild(document.createTextNode(`${contract.quantity} x ${good.name} to `)); const destSpan = document.createElement('span'); destSpan.className = 'contract-destination'; destSpan.textContent = destinationTown; li.appendChild(destSpan);
                         const detailsSpan = document.createElement('span'); detailsSpan.className = 'contract-details'; const daysLeft = contract.deadlineDay - travelCount; const deadlineClass = daysLeft <= 2 ? 'spoilage-spoiled' : daysLeft <= 5 ? 'spoilage-warning' : 'contract-deadline'; detailsSpan.innerHTML = `Reward: <span class="contract-reward">${contract.reward} G</span> | Due: Day ${contract.deadlineDay} (<span class="${deadlineClass}">${daysLeft}d left</span>)`; li.appendChild(detailsSpan);
                         contractsListEl.appendChild(li);
                     }); // End contracts FOR EACH
                 } // End contracts ELSE

                 // --- Town Info & Market ---
                 const currentTown = towns.find(t => t.id === player.currentTownId);
                 const marketControls = document.getElementById('market-controls');
                 if (currentTown) { // Start IF currentTown
                     currentTownNameEl.textContent = currentTown.name; townProducesEl.textContent = goodMap.get(currentTown.produces)?.name || 'N/A'; townDemandsEl.textContent = goodMap.get(currentTown.demands)?.name || 'N/A';
                     marketBodyEl.innerHTML = ''; // Clear market
                     currentGoods.forEach(good => { // Start market FOR EACH good
                         const marketInfo = currentTown.market?.[good.id] ?? { stock: 0, buyPrice: 999, sellPrice: 1 }; const playerHasCount = player.inventory.filter(item => item.goodId === good.id).length;
                         const row = marketBodyEl.insertRow(); const nameCell = row.insertCell(); const swatch = document.createElement('span'); swatch.className = 'good-color-swatch'; swatch.style.backgroundColor = good.color; nameCell.appendChild(swatch); nameCell.appendChild(document.createTextNode(good.name));
                         row.insertCell().textContent = marketInfo.stock; row.insertCell().textContent = playerHasCount; row.insertCell().textContent = `${marketInfo.buyPrice} G`; row.insertCell().textContent = `${marketInfo.sellPrice} G`;
                         const actionsCell = row.insertCell(); const buyButton = document.createElement('button'); buyButton.textContent = 'Buy 1'; buyButton.disabled = regionComplete || gameWon || player.gold < marketInfo.buyPrice || player.inventory.length >= player.capacity || marketInfo.stock <= 0; buyButton.onclick = () => buyGood(currentTown.id, good.id); actionsCell.appendChild(buyButton);
                         const sellButton = document.createElement('button'); sellButton.textContent = 'Sell 1'; sellButton.disabled = regionComplete || gameWon || playerHasCount <= 0; sellButton.onclick = () => sellGood(currentTown.id, good.id); actionsCell.appendChild(sellButton);
                     }); // End market FOR EACH good
                     if(marketControls) marketControls.style.display = 'block'; // Show market
                 } else { // Start ELSE currentTown
                     currentTownNameEl.textContent = 'None'; townProducesEl.textContent = 'N/A'; townDemandsEl.textContent = 'N/A'; marketBodyEl.innerHTML = '<tr><td colspan="6">Travel to a town</td></tr>';
                     if(marketControls) marketControls.style.display = 'none'; // Hide market
                 } // End ELSE currentTown

                 // --- Upgrade Button ---
                 if (player.capacity >= PLAYER_MAX_CAPACITY) { // Start IF max capacity
                     upgradeCargoBtn.textContent = "Cargo Maxed Out"; upgradeCargoBtn.disabled = true; upgradeCostEl.textContent = "";
                 } else { // Start ELSE max capacity
                     const cost = calculateUpgradeCost(); upgradeCostEl.textContent = cost; upgradeCargoBtn.disabled = regionComplete || gameWon || player.gold < cost; upgradeCargoBtn.textContent = `Upgrade Cargo (+${CARGO_UPGRADE_INCREMENT}) (${cost} G)`;
                 } // End ELSE max capacity

                 highlightCurrentTownLabel();

             // --- End Try Block ---
             } catch (uiError) { // <<<<<<<<<<<< CATCH BLOCK
                 console.error("Error during updateUI:", uiError);
             } // <<<<<<<<<<<< END CATCH BLOCK
        } // <<<<<<<<<<<< END updateUI FUNCTION

        // --- Helper Functions (highlight, distance, travelDays) ---
        function highlightCurrentTownLabel() { if(!townLabels)return; townLabels.forEach(l=>{ if(!l || !l.element || !l.userData)return; const isCurrent = l.userData.townId===player.currentTownId; const townData = towns.find(t => t.id===l.userData.townId); const colorHex = `#${new THREE.Color(townData?.color ?? 0xffffff).getHexString()}`; const isHovered = l.userData.townId === currentlyHoveredTownId; l.element.style.backgroundColor = isCurrent?'rgba(255,255,255,0.9)': isHovered ? 'rgba(100,100,100,0.8)' : 'rgba(0,0,0,0.7)'; l.element.style.color = isCurrent ? '#000' : colorHex; l.element.style.fontWeight = isCurrent ? 'bold' : 'normal'; l.element.style.padding = isCurrent ? '5px 9px' : '4px 8px'; l.element.style.borderWidth = isCurrent ? '2px' : '1px'; l.element.style.borderColor = isCurrent ? '#fff' : colorHex; }); }
        function calculateDistance(townIdA, townIdB) { const townA=towns.find(t => t.id === townIdA); const townB=towns.find(t => t.id === townIdB); if (!townA || !townB) return 0; const dx=townA.x-townB.x; const dz=townA.z-townB.z; return Math.sqrt(dx*dx+dz*dz); }
        function calculateTravelDays(fromTownId, toTownId) { if (!fromTownId || fromTownId === toTownId) return 0; const distance = calculateDistance(fromTownId, toTownId); let days = BASE_TRAVEL_DAYS + Math.floor(distance * DAYS_PER_DISTANCE_UNIT); return Math.min(days, MAX_TRAVEL_DAYS); }

        // --- Core Gameplay Functions (travel, events, buy/sell, contracts, win condition) ---
        function travelToTown(targetTownId) { if (gameWon || regionComplete) return; const targetTown = towns.find(t => t.id === targetTownId); const currentTown = towns.find(t => t.id === player.currentTownId); if (!targetTown) { console.error("Target town not found:", targetTownId); return; } if (targetTown.id === player.currentTownId) { console.log("Already in this town."); return; } let travelDays = 0; let travelCost = 0; if (currentTown) { const distance=calculateDistance(player.currentTownId, targetTownId); travelDays=calculateTravelDays(player.currentTownId, targetTownId); travelCost=BASE_TRAVEL_COST+Math.floor(distance*COST_PER_DISTANCE_UNIT); } else { console.warn("No current town set, assuming 0 cost/days."); } if (player.gold < travelCost) { showNotification(`Cannot travel. Need ${travelCost} G, you have ${player.gold} G.`, 'bad'); return; } console.log(`Traveling to ${targetTown.name}... Cost: ${travelCost} G, Days: ${travelDays}`); player.gold -= travelCost; const previousDay = travelCount; travelCount += travelDays; checkAndRemoveSpoiledGoods(travelCount); checkContractFailure(travelCount); if (Math.floor(travelCount / MARKET_SHIFT_INTERVAL) > Math.floor(previousDay / MARKET_SHIFT_INTERVAL)) { assignSpecialtiesAndDemands(); showNotification(`Market Shift!`, 'neutral'); lastMarketShiftDay = travelCount; } player.currentTownId = targetTownId; triggerArrivalParticles(new THREE.Vector3(targetTown.x, 0, targetTown.z), targetTown.color); if (Math.random() < EVENT_PROBABILITY) { triggerRandomEvent(targetTown); } else { clearNotification(); } checkContractCompletion(targetTownId); tryOfferContract(targetTown); updateUI(); checkWinCondition(); }
        function triggerRandomEvent(currentTown) { if (!currentTown) return; const event = events[Math.floor(Math.random() * events.length)]; console.log(`EVENT: ${event.name} in ${currentTown.name}`); try { const message = event.effect(currentTown); showNotification(message, event.type); } catch (e) { console.error("Error applying event effect:", event.name, e); showNotification("A strange event occurred...", 'neutral');} } // Events array needs to be defined above
        function showNotification(message, type = 'neutral') { if (eventTimeoutId) clearTimeout(eventTimeoutId); eventNotificationEl.textContent = message; eventNotificationEl.className = 'show'; eventNotificationEl.classList.remove('bad-event', 'good-event', 'neutral-event'); if (type === 'bad') { eventNotificationEl.classList.add('bad-event'); } else if (type === 'good') { eventNotificationEl.classList.add('good-event'); } else { eventNotificationEl.classList.add('neutral-event'); } eventTimeoutId = setTimeout(clearNotification, 5500); }
        function clearNotification() { eventNotificationEl.classList.remove('show', 'bad-event', 'good-event', 'neutral-event'); if (eventTimeoutId) clearTimeout(eventTimeoutId); eventTimeoutId = null; }
        function buyGood(townId, goodId) { if (gameWon || regionComplete) return; const town=towns.find(t=>t.id===townId); const good=goodMap.get(goodId); const marketInfo=town?.market?.[goodId]; if(!town||!good||!marketInfo){console.error("Buy error:",townId,goodId);return;} const currentCargo=player.inventory.length; if(player.gold>=marketInfo.buyPrice&&currentCargo<player.capacity&&marketInfo.stock>0){ const purchasePrice=marketInfo.buyPrice; player.gold-=purchasePrice; player.inventory.push({id:inventoryItemCounter++,goodId:goodId,purchasePrice:purchasePrice,originTownId:townId,purchaseDay:travelCount}); marketInfo.stock-=1; marketInfo.buyPrice=Math.max(1,Math.round(marketInfo.buyPrice*PRICE_ADJUST_BUY_FACTOR)); marketInfo.sellPrice=Math.min(marketInfo.buyPrice-1,Math.max(1,Math.round(marketInfo.sellPrice*PRICE_ADJUST_SELL_FACTOR))); marketInfo.sellPrice=Math.max(1,marketInfo.sellPrice); console.log(`Bought 1 ${good.name} for ${purchasePrice}G.`); triggerTradeParticles(new THREE.Vector3(town.x,0,town.z),good.color); updateUI();} else {console.warn("Cannot buy");} }
        function sellGood(townId, goodId) { if (gameWon || regionComplete) return; const town=towns.find(t=>t.id===townId); const good=goodMap.get(goodId); const marketInfo=town?.market?.[goodId]; if(!town||!good||!marketInfo){console.error("Sell error:",townId,goodId);return;} let itemIndex=-1; let oldestPurchaseDay=Infinity; for(let i=0;i<player.inventory.length;i++){if(player.inventory[i].goodId===goodId&&player.inventory[i].purchaseDay<oldestPurchaseDay){oldestPurchaseDay=player.inventory[i].purchaseDay;itemIndex=i;}} if(itemIndex===-1){console.warn(`Cannot sell ${good.name}, not found.`); checkAndRemoveSpoiledGoods(travelCount); updateUI(); return;} const itemToSell=player.inventory[itemIndex]; if(PERISHABLE_GOODS.has(goodId)&&travelCount-itemToSell.purchaseDay>=SPOILAGE_DAYS){console.warn(`Selling spoiled ${good.name}. Removing.`); player.inventory.splice(itemIndex,1); showNotification(`${good.name} spoiled!`, 'bad'); updateUI(); return;} const sellPrice=marketInfo.sellPrice; player.gold+=sellPrice; player.inventory.splice(itemIndex,1); marketInfo.stock+=1; marketInfo.sellPrice=Math.max(1,Math.round(marketInfo.sellPrice*PRICE_ADJUST_SELL_FACTOR)); marketInfo.buyPrice=Math.max(marketInfo.sellPrice+1,Math.round(marketInfo.buyPrice*PRICE_ADJUST_SELL_FACTOR)); console.log(`Sold 1 ${good.name} for ${sellPrice}G.`); triggerTradeParticles(new THREE.Vector3(town.x,0,town.z),good.color); updateUI();}
        function checkAndRemoveSpoiledGoods(currentDay) { let removedCount=0; const newlySpoiledGoods=new Set(); player.inventory=player.inventory.filter(item=>{if(PERISHABLE_GOODS.has(item.goodId)){const daysHeld=currentDay-item.purchaseDay; if(daysHeld>=SPOILAGE_DAYS){console.log(`Item ${item.id} (${goodMap.get(item.goodId)?.name}) spoiled!`); newlySpoiledGoods.add(goodMap.get(item.goodId)?.name||'Unknown'); removedCount++; return false;}} return true;}); if(removedCount>0){const goodsList=Array.from(newlySpoiledGoods).join(', '); showNotification(`${removedCount} item(s) spoiled (${goodsList})!`, 'bad'); updateUI();} }
        function calculateUpgradeCost() { const upgradesDone=(player.capacity-PLAYER_START_CAPACITY)/CARGO_UPGRADE_INCREMENT; return CARGO_UPGRADE_BASE_COST + Math.round(upgradesDone*upgradesDone*20); }
        function attemptCargoUpgrade() { if (gameWon || regionComplete || player.capacity >= PLAYER_MAX_CAPACITY) return; const cost = calculateUpgradeCost(); if (player.gold >= cost) { player.gold -= cost; player.capacity += CARGO_UPGRADE_INCREMENT; console.log(`Upgraded cargo to ${player.capacity} for ${cost}G.`); showNotification(`Cargo capacity increased to ${player.capacity}!`, 'good'); updateUI(); } else { console.warn(`Need ${cost - player.gold} more G to upgrade.`); showNotification(`Need ${cost - player.gold} more Gold to upgrade cargo!`, 'bad'); } }
        function generateContract(originTown) { if (!originTown) return null; const possibleGoods=currentGoods.filter(g=>g.id!==originTown.produces&&g.id!==originTown.demands); if(possibleGoods.length===0)return null; const targetGood=possibleGoods[Math.floor(Math.random()*possibleGoods.length)]; const possibleDestinations=towns.filter(t=>t.id!==originTown.id); if(possibleDestinations.length===0)return null; const destinationTown=possibleDestinations[Math.floor(Math.random()*possibleDestinations.length)]; const quantity=Math.max(1, Math.floor(Math.random()*(player.capacity*0.3))+2); const deadline=travelCount+CONTRACT_DEADLINE_MIN_DAYS+Math.floor(Math.random()*(CONTRACT_DEADLINE_MAX_DAYS-CONTRACT_DEADLINE_MIN_DAYS+1)); const baseValue=targetGood.basePrice*quantity; const distance=calculateDistance(originTown.id,destinationTown.id); const distanceFactor=1+(distance/(MAP_SIZE*0.8)); const reward=Math.round(baseValue*CONTRACT_REWARD_FACTOR*distanceFactor); const newContract={id:contractIdCounter++,goodId:targetGood.id,quantity:quantity,destinationTownId:destinationTown.id,originTownId:originTown.id,reward:reward,deadlineDay:deadline}; console.log(`Generated Contract #${newContract.id}: ${quantity} ${targetGood.name} to ${destinationTown.name} by Day ${deadline} for ${reward}G.`); return newContract; }
        function tryOfferContract(town) { if (gameWon||regionComplete||player.contracts.length>=MAX_ACTIVE_CONTRACTS) return; const existingContractFromTown=player.contracts.some(c=>c.originTownId===town.id); if(existingContractFromTown)return; if (Math.random()<CONTRACT_OFFER_CHANCE){ const contract=generateContract(town); if(contract){ player.contracts.push(contract); showNotification(`${town.name} offers contract: ${contract.quantity} ${goodMap.get(contract.goodId).name} to ${townNameMap.get(contract.destinationTownId)} by Day ${contract.deadlineDay} (${contract.reward} G)!`, 'good'); updateUI(); } } }
        function checkContractCompletion(arrivalTownId) { if (gameWon||regionComplete) return; const completedContracts=[]; player.contracts=player.contracts.filter(contract=>{ if (contract.destinationTownId===arrivalTownId&&travelCount<=contract.deadlineDay){ const requiredGoodId=contract.goodId; const requiredQuantity=contract.quantity; const availableItems=player.inventory.filter(item=>item.goodId===requiredGoodId); if (availableItems.length>=requiredQuantity){ console.log(`Contract #${contract.id} completed!`); player.gold+=contract.reward; availableItems.sort((a,b)=>a.purchaseDay-b.purchaseDay); const itemsToRemoveIds=new Set(availableItems.slice(0, requiredQuantity).map(item=>item.id)); player.inventory=player.inventory.filter(item=>!itemsToRemoveIds.has(item.id)); completedContracts.push(contract); showNotification(`Contract complete! Delivered ${requiredQuantity} ${goodMap.get(requiredGoodId).name} to ${townNameMap.get(arrivalTownId)}. +${contract.reward} G!`, 'good'); return false; } else { console.log(`Arrived at ${townNameMap.get(arrivalTownId)} for contract #${contract.id}, but lacked goods.`); } } return true; }); if (completedContracts.length > 0) { updateUI(); } }
        function checkContractFailure(currentDay) { if (gameWon||regionComplete) return; let failedCount = 0; player.contracts=player.contracts.filter(contract=>{ if (currentDay > contract.deadlineDay) { console.log(`Contract #${contract.id} failed.`); showNotification(`Contract failed! Delivery of ${contract.quantity} ${goodMap.get(contract.goodId).name} to ${townNameMap.get(contract.destinationTownId)} missed deadline.`, 'bad'); failedCount++; return false; } return true; }); if (failedCount > 0) { updateUI(); } }
        function checkWinCondition() { if (gameWon || regionComplete) return; if (player.gold >= currentWinTarget) { console.log(`--- Region ${currentRegionIndex} Complete ---`); regionComplete = true; clearNotification(); if (currentRegionIndex + 1 < regionThemes.length) { const nextRegion = regionThemes[currentRegionIndex + 1]; regionCompleteTitle.textContent=`${regionThemes[currentRegionIndex].name} Complete!`; regionCompleteText.textContent=`Mastered ${regionThemes[currentRegionIndex].name}! Gold: ${player.gold} G. Continue to ${nextRegion.name}? (Goal: ${nextRegion.winTarget} G)`; regionCompletePrompt.classList.add('show'); } else { triggerFinalWin(); } disableInteractionButtons(true); } }
        function moveToNextRegion() { if (!regionComplete) return; console.log("Moving to next region..."); startGameRegion(currentRegionIndex + 1, true); }
        function triggerFinalWin() { console.log("--- GAME WON (Final) ---"); gameWon=true; regionComplete=false; hidePrompts(); winMessageText.textContent=`Conquered all regions! Final Gold: ${player.gold} G.`; winMessage.classList.add('show'); showNotification("ðŸ† GRAND TRADER OF ALL REALMS! ðŸ†", 'good'); if(eventTimeoutId)clearTimeout(eventTimeoutId); disableInteractionButtons(true); }
        function hidePrompts() { regionCompletePrompt.classList.remove('show'); winMessage.classList.remove('show'); }
        function disableInteractionButtons(disabled) { const buttons=document.querySelectorAll('#market-table button, #upgrade-cargo-btn'); buttons.forEach(button=>button.disabled=disabled); }

        // --- Event Handlers ---
        function setupEventListeners() {
             window.addEventListener('resize', onWindowResize, false);
             if (renderer && renderer.domElement) {
                 renderer.domElement.addEventListener('click', onMouseClick, false);
                 renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                 console.log("Canvas event listeners added.");
             } else { console.error("Renderer not ready during setupEventListeners!"); }
             window.addEventListener('keydown', handleDebugKeys); // DEBUG LISTENER
             upgradeCargoBtn.addEventListener('click', attemptCargoUpgrade);
             resetBtn.addEventListener('click', () => { if (confirm("Reset the entire game?")) { location.reload(); } });
             continueBtn.addEventListener('click', moveToNextRegion);
             stopBtn.addEventListener('click', () => { if (regionComplete) triggerFinalWin(); });
             console.log("UI button listeners added.");
        }
        function handleDebugKeys(event) { if (event.shiftKey && event.key === 'D') { event.preventDefault(); const amountStr = prompt("DEBUG: Enter amount of gold to add:", "5000"); if (amountStr === null) { console.log("Debug gold add cancelled."); return; } const amount = parseInt(amountStr, 10); if (!isNaN(amount) && amount > 0) { player.gold += amount; console.log(`DEBUG: Added ${amount} gold. New total: ${player.gold}`); showNotification(`DEBUG: Added ${amount} G`, 'good'); updateUI(); checkWinCondition(); } else { console.warn("DEBUG: Invalid amount entered."); showNotification("DEBUG: Invalid amount.", 'bad'); } } }
        function onWindowResize() { if(!camera||!renderer||!css2dRenderer)return;const w=container.clientWidth;const h=container.clientHeight;camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);css2dRenderer.setSize(w,h);}
        function onMouseClick(event) { if(gameWon || regionComplete) return; const r=renderer.domElement.getBoundingClientRect();mouse.x=((event.clientX-r.left)/r.width)*2-1;mouse.y=-((event.clientY-r.top)/r.height)*2+1;raycaster.setFromCamera(mouse,camera);const i=raycaster.intersectObjects(townObjects);if(i.length>0){const o=i[0].object;if(o.userData.type==='town'){ if(o.userData.townId!==player.currentTownId){travelToTown(o.userData.townId);}else{console.log("Clicked on current town.");}} } }
        function onMouseMove(event) { if (gameWon || regionComplete) return; const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(townObjects); let intersectedTownId = null; if (intersects.length > 0) { intersectedTownId = intersects[0].object.userData.townId; } if (intersectedTownId !== currentlyHoveredTownId) { if (currentlyHoveredTownId !== null) { const previousLabel = townLabels.find(l => l.userData.townId === currentlyHoveredTownId); if (previousLabel && originalLabelContent !== null) { previousLabel.element.innerHTML = originalLabelContent; } } if (intersectedTownId !== null) { const newLabel = townLabels.find(l => l.userData.townId === intersectedTownId); if (newLabel) { originalLabelContent = newLabel.element.innerHTML; let daysText = ""; if (player.currentTownId && intersectedTownId !== player.currentTownId) { const travelDays = calculateTravelDays(player.currentTownId, intersectedTownId); daysText = `<span class="travel-time">(Travel: ${travelDays}d)</span>`; } newLabel.element.innerHTML = originalLabelContent + daysText; } } else { originalLabelContent = null; } currentlyHoveredTownId = intersectedTownId; highlightCurrentTownLabel(); } }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Call first
            try {
                 const deltaTime = clock.getDelta();
                 if (!gameWon && !regionComplete) { controls.update(); }
                 updateParticleSystems(deltaTime);
                 if (renderer && scene && camera) { renderer.render(scene, camera); }
                 else { console.warn("Render components not ready."); return; } // Prevent errors if init failed mid-way
                 if (css2dRenderer && scene && camera) { css2dRenderer.render(scene, camera); }
            } catch (error) {
                console.error("Error in animation loop:", error);
                // Consider adding a way to stop the loop if errors persist
                // cancelAnimationFrame(animationFrameId); // requires storing the id
            }
        }

        // --- Define Events Array (Needs to be defined before use in triggerRandomEvent) ---
        const events = [
            {name:"Bumper Harvest",type:"good",effect:(t)=>{const g=goodMap.get(t.produces);if(!g||!t.market[t.produces])return`${t.name} issue.`;t.market[t.produces].stock=Math.round(t.market[t.produces].stock*1.5)+5;t.market[t.produces].buyPrice=Math.max(1,Math.round(t.market[t.produces].buyPrice*0.8));return`${t.name} bumper harvest of ${g.name}!`;}},
            {name:"Trade Festival",type:"good",effect:(t)=>{Object.values(t.market).forEach(m=>{m.buyPrice=Math.max(1,Math.round(m.buyPrice*0.9));m.sellPrice=Math.max(1,Math.round(m.sellPrice*1.15));});return`Festival in ${t.name}! Sell prices up.`;}},
            {name:"Bandit Toll",type:"bad",effect:(t)=>{const toll=Math.min(player.gold,Math.max(10,Math.floor(player.gold*0.1)));player.gold-=toll;updateUI(); return`Bandits demand ${toll} G near ${t.name}!`;}}, // Ensure UI updates after gold loss
            {name:"Poor Weather",type:"bad",effect:(t)=>{const g=goodMap.get(t.produces);if(!g||!t.market[t.produces])return`${t.name} issue.`;t.market[t.produces].stock=Math.max(1,Math.round(t.market[t.produces].stock*0.6));t.market[t.produces].buyPrice=Math.max(1,Math.round(t.market[t.produces].buyPrice*1.2));return`Poor weather hits ${t.name}'s ${g.name} production.`;}},
            {name:"Market Rumor",type:"neutral",effect:(t)=>{const g=currentGoods[Math.floor(Math.random()*currentGoods.length)];const d=Math.random()<0.5;if(d){t.market[g.id].sellPrice=Math.max(1,Math.round(t.market[g.id].sellPrice*1.2));return`Rumors in ${t.name}: high demand for ${g.name}!`;}else{t.market[g.id].buyPrice=Math.max(1,Math.round(t.market[g.id].buyPrice*0.8));return`Rumors in ${t.name}: oversupply of ${g.name}!`;}}},
        ];

        // --- Start ---
        init();

    </script>
</body>
</html>